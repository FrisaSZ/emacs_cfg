;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 基本执行
;; 使用C-x C-e来执行上一条符号表达式，对应函数是eval-last-sexp
;; 在echo area显示十进制、八进制、十六进制的结果
(+ 1 2)
(+ 3 4)
;; elisp中一个字符就是一个整数(字符本身的Unicode码)

;; 打印
;; 普通打印字符串
(message "I'm FSZ")
;; 打印格式化字符串，和C语言类似
(message "My name is : %s, I'm %d years old." "FSZ" 28)
;; 用S做占位符，会把后面lisp表达式的运算结果填进来
(message "My list is %S" (list 1 2 3 4 5))
(message "My sum is %S" (+ 2 2))
;; 实际上S能作为任意表达式的占位符，所以前面的数字和字符串都可以用S
;; 用C-h e能打开message buffer查看之前的输出信息

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 基本算数
(+ 1 2 3)
(- 3 2)
(* 2 3)
(* 1 2 3 4 5 6 7 8 9)
;; 除法
(/ 7 2)
(/ 7 2.0)
;; 余数
(% 7 4)
;; 指数
(expt 2 5)
;; 判断数据类型，3.是整型，3.0是浮点型，通常p结尾的函数返回true或false
;; p是predicate断言的简写，elisp里t代表true，nil代表false
(integerp 3.)
(floatp 3.)
(floatp 3.0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 数据类型转换
;; 整型转浮点型
(float 3)
;; 截取浮点型的整数部分，和向下取整相似，但在负数上结果不同
;; 总是朝0的方向取整数
(truncate 3.3)
(truncate -3.3)
;; 向下取整，总是朝小的方向取整数
(floor 3.3)
(floor -3.3)
;; 向上取整，总是朝大的方向取整数
(ceiling 3.3)
(ceiling -3.3)
;; 取最近的整数，四舍五入，不过在某些机器上2.5会返回2
(round 3.5)
(round 3.4)
;; 字符串转数字，如果输入的字符串不能解析为数字，就返回0
(string-to-number "3")
;; 数字转字符串
(number-to-string 3)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 真假判断
;; elisp中nil作为false，其他任何符号都作为true，nil也等价于空list ()，所以()也代表false
;; 下面的例子全是假
(if nil "yes" "no")
(if () "yes" "no")
(if '() "yes" "no")
;; (list)等价于一个空list ()
(if (list) "yes" "no")
;; 除了nil其他都为真，下面全是真的例子，为了方便通常用t代表true
(if t "yes" "no")
(if 0 "yes" "no")
(if "" "yes" "no")
;; []是一个包含0个元素的vector
(if [] "yes" "no")
;; elisp中没有布尔型数据，nil和空list代表false，其他都代表true

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 布尔型函数
;; 逻辑与
(and t nil)
;; 逻辑或
(or t nil)
;; 也可以接受多个参数
(and t t t t nil)
(or t nil nil nil nil)
;; 数值比较
(< 3 4)
(> 3 4)
(<= 3 4)
(>= 3 4)
(= 3 3)
(= 3 3.0000)
;; equal用于判断两个lisp对象，对于数值相同的整型和浮点型由于数据类型不同会返回nil，这点和=号不同
(equal 3 3)
(equal 3 3.0)
;; equal也可用于判断list
(equal '(3 4 5) '(3 4 5))
(equal '(3 4 5) '(3 4 "5"))
;; 除此之外还有一个eq函数，仅当两个参数代表同一个lisp对象时返回true
(eq "e" "e")
;; 不等于
(/= 3 4)
;; /=只能用于数值的比较，对于其他类型，需要用not对逻辑取反来做不等的断言
(not (= 3 4))
(not (equal "abc" "Abc"))
;; 字符串比较
(equal "abc" "abc")
;; 专门的字符串比较函数
(string-equal "abc" "abc")
(string-equal "abc" "Abc")
;; string-equal也可以用于比较字符串和符号
(string-equal "abc" 'abc)
;; 判断奇偶
(= (% 10 2) 0)
(= (% 11 2) 1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 变量
;; 全局变量
;; setq设置变量的值(setq [SYM VAL] ...)，变量不需要声明，是全局的
(setq x 1)
;; 变量符号不会被执行(eval)，数值部分会被执行(eval)
(setq a (+ 1 2))
;; 一次设多个变量
(setq a 1 b 2 c 3)
;; 仅当前一个变量设置完成后后面的可执行部分才会执行，所以后面的执行语句可以使用前面设置过的变量的值
(setq a 1 b 2 c (+ a b))
;; setq语句的返回值是最后一个VAL的值
;; 局部变量，局部作用域的变量，变量的绑定只在let的语句范围内有效
;; let有两种使用方式: 1. let (VARLIST)相当于声明了一系列的局部作用域变量并绑定值为nil，然后在后面
;; 的操作中可以使用这些变量；2. let ((SYM VAL) (SYM VAL))直接为变量绑定需要的值，然后在后面的操作中直接
;; 用就行
(let (a b)
  (setq a 3)
  (setq b 4)
  (+ a b))
(let ((a 7)(b 4))
  (+ a b))
;; 下面的setq把a在全局作用域下绑定为1111
;; let把a在局部范围内绑定为2222，所以在let后面eval得到2222，再在后面的单个a上eval得到的还是原来的1111
;; 这就是在局部作用域内a的全局值被覆盖了
(setq a 1111)
(let ((a 2222))
  a)
a
;; let内使用setq依然是在局部作用域内的修改
(let (a)
  (setq a 3333))
a

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if then else
;; if表达式的格式是(if test body)
;; 有else的情形，格式是(if test true_body false_body)
(if (< 1 2) (message "true_body") (message "false_body"))
(if (< 3 2) (message "true_body"))
;; 当没有else的情形时应该用(when test expr1 expr2)的形式，更加清晰简洁，这就等价于(if test (progn expr1 expr2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 表达式块progn，用于把一组表达式用一个括号包起来，按顺序执行，另外progn会返回最后一个表达式的值
(progn (message "a")(message "b")(message "c"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 循环loop，(while test body)，1+是个函数，返回x+1
(setq x 0)
(while (< x 4)
  (print (format "number is %d" x))
  (setq x (1+ x)))
(let ((x 32))
  (while (< x 127)
    (insert-char x)
    (setq x (+ x 1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 定义函数
